# PUF to IRS Variable Mapping

This document maps PUF (Public Use File) variables to corresponding values in IRS spreadsheets for 2015 (the PUF year) and 2022 (for comparison).

## Overview

This mapping documents the relationships between: - PUF microdata variables (2015) - IRS spreadsheet totals for 2015 - TMD (Tax Microdata) values for 2022 - IRS spreadsheet totals for 2022

The goal is to establish appropriate mappings for setting national targets based on IRS data.

Steps:

-   compare reported aggregates in IRS tables for 2015 to the documentation for 2015

```{r}
#| label: setup

GITROOT <- rprojroot::find_root(rprojroot::has_file(".git/index"))
QROOT <- fs::path(GITROOT, "tmd", "national_targets", "qmd")
source(fs::path(QROOT, "setup.R"))

# note - will load the functions that help with reading excel files
# loads DATADIR, and targfn

```

## Get puf sums, puf code counts, and IRS potential targets

```{r}
#| label: get-potential-targets

pufsums <- read_csv(fs::path(DATADIR, "pufsums.csv"))
puf_codecounts <- read_csv(fs::path(DATADIR, "puf_codecounts.csv"))
ptargets <- read_csv(fs::path(DATADIR, "potential_targets_preliminary.csv"))

```

```{r}
#| label: ptargets-info
#| output: true

glimpse(ptargets)

skimr::skim_without_charts(ptargets)
count(ptargets, table, fname)
count(ptargets, table)
count(ptargets, year, vtype, subgroup, marstat)

```

### Construct a streamlined puf-matching file

```{r}

sumsbase <- pufsums |>
  select(pufname, pufdescription, soi = soi2015_adj) |>
  mutate(
    vtype = "amount",
    subgroup = "filers",
    marstat = "all",
    src = "pufsums",
    .after = pufname
  )

mstat_lookup <- c(
  `1` = "single",
  `2` = "mfjss",
  `3` = "mfs",
  `4` = "hoh"
)
codebase <- puf_codecounts |>
  filter(code %in% 1:4) |>
  mutate(
    pufname = "E00100",
    pufdescription = code_description,
    vtype = "count",
    subgroup = "filers",
    marstat = unname(mstat_lookup[as.character(code)]),
    src = "pufcodes"
  ) |>
  select(pufname, vtype, subgroup, marstat, pufdescription, soi = soi2015, src)
codebase

soi_base <- bind_rows(sumsbase, codebase) |>
  mutate(year = 2015, incsort = 1, pufdocrow = row_number())


```

## Begin mapping PUF variables to IRS totals

Compare full-sample totals for PUF variables to IRS totals

```{r}
#| output: false

count(ptargets, table, fname)
count(ptargets, vtype)
count(ptargets, subgroup)
count(ptargets, marstat)

check <- ptargets |>
  filter(incsort == 1, marstat != "all", year == 2015, vtype == "count")

ptargets_base <- ptargets |>
  filter(
    year == 2015,
    # vtype == "amount",
    subgroup %in% c("filers"),
    marstat == "all",
    incsort == 1
  )

```

### Round 1: EXACT MATCH

Start by finding exact matches between expected IRS totals (soi2015) and actual IRS totals pulled from spreadsheets.

```{r}
#| label: round1-explore

ptol <- 0.0

compare1 <- soi_base |>
  mutate(
    lb = soi * (1 - ptol),
    ub = soi * (1 + ptol)
  ) |>
  left_join(
    ptargets_base,
    join_by(
      year,
      vtype,
      subgroup,
      marstat,
      incsort,
      lb <= ptarget,
      ub >= ptarget
    )
  ) |>
  filter(!is.na(ptarget)) |>
  mutate(diff = ptarget - soi, pdiff = diff / soi) |>
  select(
    pufdocrow,
    pufname,
    pufdescription,
    vdescription,
    vname,
    vtype,
    subgroup,
    marstat,
    vdescription,
    soi,
    ptarget,
    diff,
    pdiff,
    everything()
  ) |>
  arrange(pufdocrow)

# inspection shows duplicates:
#    tab12-2015-exemption-amount-filers-all
#    tab14-2015-exemption-amount-filers-all
#  let's drop the tab14 version for now

```

```{r}
comma_vars <- c("soi", "ptarget", "diff")
pct_vars <- c("pdiff")
```

```{r}
#| label: show-round1
#| output: true

compare1 |>
  select(
    idbase,
    pufname,
    vname,
    soi,
    ptarget,
    diff,
    pdiff,
    pufdescription,
    vdescription,
    table,
    vtype,
    subgroup,
    marstat,
    fname,
    xlcell
  ) |>
  gt() |>
  tab_header("Round 1 exact match results") |>
  fmt_number(columns = comma_vars, decimals = 0) |>
  fmt_percent(columns = pct_vars, decimals = 2)

```

Duplicate matches

```{r}
#| output: true

compare1 |>
  select(
    idbase,
    pufname,
    vname,
    soi,
    ptarget,
    diff,
    pdiff,
    pufdescription,
    vdescription,
    table,
    vtype,
    subgroup,
    marstat,
    fname,
    xlcell
  ) |>
  mutate(n = n(), .by = pufname) |>
  filter(n > 1) |>
  gt() |>
  tab_header(
    "Round 1 duplicates where puf variable has more than 1 exact matches"
  ) |>
  fmt_number(columns = comma_vars, decimals = 0) |>
  fmt_percent(columns = pct_vars, decimals = 2)

```

#### Get round1 results. Should we keep unique only?

```{r}

round1 <- compare1


# ptargets |> filter(idbase == "tab12-2015-agi-amount-filers-all")
# ptargets |> filter(idbase == "tab12-2015-agi-amount-filers-mfjss")
# ptargets |> filter(idbase == "tab12-2015-agi-count-filers-mfjss")

```

### Round 2: Near-exact matches (expected amounts within 0.1% of IRS)

```{r}

ptol <- 0.001

compare2 <- compdata |>
  mutate(lb = soi2015_adj * (1 - ptol), ub = soi2015_adj * (1 + ptol)) |>
  left_join(comptargets, join_by(lb <= ptarget, ub >= ptarget)) |>
  filter(!is.na(ptarget)) |>
  mutate(diff = ptarget - soi2015_adj, pdiff = diff / soi2015_adj) |>
  relocate(vname, .after = description) |>
  relocate(c(ptarget, diff, pdiff), .after = soi2015_adj) |>
  arrange(desc(soi2015_adj), desc(abs(diff)))

ptol <- 0.0

compare2 <- soi_base |>
  filter(!pufdocrow %in% round1$pufdocrow) |>
  mutate(
    lb = soi * (1 - ptol),
    ub = soi * (1 + ptol)
  ) |>
  left_join(
    ptargets_base,
    join_by(
      year,
      vtype,
      subgroup,
      marstat,
      incsort,
      lb <= ptarget,
      ub >= ptarget
    )
  ) |>
  filter(!is.na(ptarget)) |>
  mutate(diff = ptarget - soi, pdiff = diff / soi) |>
  select(
    pufdocrow,
    pufname,
    pufdescription,
    vdescription,
    vname,
    vtype,
    subgroup,
    marstat,
    vdescription,
    soi,
    ptarget,
    diff,
    pdiff,
    everything()
  ) |>
  arrange(pufdocrow)


```


```{r}
#| label: show-round2
#| output: true

compare2 |>
  select(
    targetid,
    puf_name:pufsumk,
    table,
    datatype,
    subgroup,
    targtype,
    fname,
    xlcolumn,
    xlrownum
  ) |>
  gt() |>
  tab_header("Round 2 near-exact match results") |>
  fmt_number(columns = comma_vars, decimals = 0) |>
  fmt_percent(columns = pct_vars, decimals = 2)

```

There are 3 extremely close matches. The only one that appears valid is E01500 and pensions, which have the same basic name and are within \$1. The others are not matches.

```{r}

# it's obvious there are no dups
round2 <- compare2 |> filter(puf_name == "E01500")

```


### Round 3: Close matches (expected amounts within 1% of IRS)


```{r}

ptol <- 0.01
compare3 <- compdata |>
  filter(!puf_name %in% c(round1$puf_name, round2$puf_name)) |>
  mutate(lb = soi2015_adj * (1 - ptol), ub = soi2015_adj * (1 + ptol)) |>
  left_join(comptargets, join_by(lb <= ptarget, ub >= ptarget)) |>
  filter(!is.na(ptarget)) |>
  mutate(diff = ptarget - soi2015_adj, pdiff = diff / soi2015_adj) |>
  relocate(vname, .after = description) |>
  relocate(c(ptarget, diff, pdiff), .after = soi2015_adj) |>
  arrange(desc(soi2015_adj), desc(abs(diff)))

# which if any of these targets were NOT already used in round 1 or round 2

compare3a <- compare3 |>
  filter(!targetid %in% c(round1$targetid, round2$targetid))

```


Round 3 is a bust:

- Only 6 IRS targets were found that were not previously paired with an expected total
- Based on variable descriptions, NONE was a good match.

```{r}

amount_matches <- bind_rows(round1, round2)

amount_matches |>
  select(
    targetid,
    puf_name:pufsumk,
    table,
    datatype,
    subgroup,
    targtype,
    fname,
    xlcolumn,
    xlrownum
  ) |>
  gt() |>
  tab_header("Good matches for amount variables after 3 rounds") |>
  fmt_number(columns = comma_vars, decimals = 0) |>
  fmt_percent(columns = pct_vars, decimals = 2)

```
